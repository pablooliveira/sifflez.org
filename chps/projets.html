<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Projets M1 - CHPS</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="pandoc.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Projets M1 - CHPS</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#planning-2020---2021">Planning 2020 - 2021</a><ul>
<li><a href="#soutenances-1ère-période-22-janvier">Soutenances 1ère période 22 janvier</a></li>
</ul></li>
<li><a href="#organisation">Organisation</a><ul>
<li><a href="#choix-du-groupe-et-du-sujet">Choix du groupe et du sujet</a></li>
<li><a href="#prise-de-contact-avec-lencadrant-et-déroulement-des-projets">Prise de contact avec l’encadrant et déroulement des projets</a></li>
<li><a href="#rapports-et-soutenances">Rapports et soutenances</a></li>
</ul></li>
<li><a href="#sujets">Sujets</a><ul>
<li><a href="#détection-de-communautés-dans-les-réseaux-sociaux">1) Détection de communautés dans les réseaux sociaux</a></li>
<li><a href="#analyseur-de-codes-génétiques">2) Analyseur de codes génétiques</a></li>
<li><a href="#réseau-de-neurones-à-convolution-reconaissance-dimages">3) Réseau de Neurones à Convolution (reconaissance d’images)</a></li>
<li><a href="#calcul-de-densité-détat-de-particule-pour-la-modélisation-de-nanoparticule-à-transition-de-spin-sco-selon-un-modèle-dising.">4) Calcul de densité d’état de particule pour la modélisation de nanoparticule à transition de spin (SCO) selon un modèle d’Ising.</a></li>
<li><a href="#utilisation-et-analyse-critique-des-rapports-maqao-pour-optimiser-des-mini-apps">5) Utilisation et analyse critique des rapports MAQAO pour optimiser des mini-apps</a></li>
<li><a href="#conversion-automatique-des-codes-de-calcul-hpc-en-virgule-flottante-vers-la-virgule-fixe">6) Conversion automatique des codes de calcul HPC en virgule flottante vers la virgule fixe</a></li>
<li><a href="#support-mpi-dans-verificarlo">7) Support MPI dans Verificarlo</a></li>
<li><a href="#différentiation-automatique">8) Différentiation Automatique</a></li>
</ul></li>
</ul>
</nav>
<h1 id="planning-2020---2021">Planning 2020 - 2021</h1>
<p>Les projets sont divisés en deux périodes. Les dates importantes sont les suivantes.</p>
<ul>
<li>1er semestre: Responsable Pablo Oliveira
<ul>
<li><strong>08 octobre à 9h30</strong>: Réunion de présentation des projets</li>
<li><strong>11 octobre minuit</strong>: Date limite pour la constitution des groupes et choix des sujets</li>
<li><strong>17 janvier minuit</strong>: Date limite pour le rendu des rapports première période</li>
<li><strong>22 janvier de 10h à 16h00</strong>: Soutenance première période</li>
</ul></li>
<li>2ème semestre: Responsable Thomas Dufaud
<ul>
<li><strong>fin mars</strong>Création des comptes étudiants sur la machine parallèle du Li-PaRAD (S. Ibnamar)</li>
<li><strong>2 mai minuit</strong>: Date limite pour le rendu des rapports deuxième période</li>
<li><strong>7 mai de 10h00 à 16h00</strong>: Soutenance deuxième période</li>
</ul></li>
</ul>
<h2 id="soutenances-1ère-période-22-janvier">Soutenances 1ère période 22 janvier</h2>
<p>Les soutenances auront lieu en distanciel sur Zoom (un lien vous a été envoyé par mail). Assister aux soutenances de vos camarades est enrichissant, c’est pourquoi la présence est obligatoire à l’ensemble des soutenances.</p>
<p>Vous disposez de quinze minutes de présentation et dix minutes de questions. Assurez vous que vos transparents (.pdf, .pptx, .odp, etc) marchent sur l’outil Zoom.</p>
<pre><code> 10h00-10h30 Sujet 1
 10h30-11h00 Sujet 2
 11h00-11h30 Sujet 3
 11h30-12h00 Sujet 4

 14h00-14h30 Sujet 5
 14h30-15h00 Sujet 6
 15h00-15h30 Sujet 7
 15h30-16h00 Sujet 8</code></pre>
<h1 id="organisation">Organisation</h1>
<h2 id="choix-du-groupe-et-du-sujet">Choix du groupe et du sujet</h2>
<p>Il faut constituer des groupes de quatre personnes. Chaque groupe choisira trois des sujets ci-dessous et les classera par ordre de préférence.</p>
<p>Pour indiquer votre choix de groupe et de sujet, merci d’envoyer un mail à &lt; pablo POINT oliveira ARROBASE uvsq POINT fr &gt;. Suivez scrupuleusement les instructions suivantes:</p>
<ul>
<li>Sur le champ <strong>Objet</strong>, indiquez « [PPN] Choix du sujet ».</li>
<li>En <strong>CC</strong> du mail mettez les adresses email UVSQ de tous les membres du groupe.</li>
<li>Dans le corps du mail donnez trois sujets par ordre de préférence.</li>
</ul>
<p>Les sujets seront attribués en essayant de satisfaire vos choix. Si votre mail ne respecte pas les consignes ci-dessus (il manque des membres en CC, il n’y a pas trois sujets, etc.), vous serez moins prioritaire sur le choix des sujets que les groupes ayant respecté les consignes.</p>
<p>Les attributions finales de projet vous seront communiquées rapidement.</p>
<h2 id="prise-de-contact-avec-lencadrant-et-déroulement-des-projets">Prise de contact avec l’encadrant et déroulement des projets</h2>
<p>Une fois votre sujet final confirmé vous devez prendre contact avec l’encadrant. L’encadrant vous indiquera ce qu’il attends de vous dans le projet et quels sont les objectifs pour la première et deuxième période.</p>
<p>L’encadrant pourra vous aider par mail et vous proposer plusieurs rendez vous au cours de l’année. C’est <strong>votre responsabilité</strong> de prendre contact avec lui et de lui demander des rendez vous ou lui poser des questions quand vous avez besoin d’aide.</p>
<p>On vous conseille le déroulement suivant (à minima, bien sûr vous pouvez demander d’autres rendez vous):</p>
<ul>
<li><p>Premier rdv en octobre après avoir fait un premier état de l’art sur le sujet proposé</p></li>
<li><p>Deuxième rdv en novembre pour faire un point à mi-semestre</p></li>
<li><p>Troisième rdv début janvier pour faire un point avant la première soutenance et discuter des objectifs de la deuxième période</p></li>
<li><p>Quatrième rdv en avril pour faire un point avant la soutenance finale</p></li>
<li><p>Rendez vous à la demande selon vos besoins et la disponibilité de l’encadrant (pensez à prendre rdv à l’avance par mail).</p></li>
</ul>
<h2 id="rapports-et-soutenances">Rapports et soutenances</h2>
<p>À la fin de chaque période un rapport sera envoyé par mail en mettant en destinataires &lt;responsable-m1-chps ARROBASE sympa.uvsq.fr&gt; et votre encadrant.</p>
<p>Chaque rapport doit faire environ 10 pages en police 11 simple interligne. Ceci sans compter les figures ou les pages blanches, soit environ 4000 mots.</p>
<p>Le plagiat est strictement interdit, nous vous invitons à prendre connaissance de la <a href="http://www.uvsq.fr/section-disciplinaire-competente-a-l-egard-des-usagers-393781.kjsp">charte anti-plagiat</a>.</p>
<p>Le code source produit durant le projet sera propre, indenté, commenté et documenté. Il peut être envoyé sous forme d’archive <code>.tar.gz</code> ou d’un lien vers un dépôt public.</p>
<p>Il faudra aussi préparer une présentation de 15 minutes avec 10 minutes de questions.</p>
<h1 id="sujets">Sujets</h1>
<h2 id="détection-de-communautés-dans-les-réseaux-sociaux">1) Détection de communautés dans les réseaux sociaux</h2>
<ul>
<li>Encadrant: George Manoussakis</li>
<li>E-Mail: &lt; oreste POINT manoussakis ARROBASE uvsq.fr &gt;</li>
</ul>
<p>Le but du projet est d’implémenter pour des graphes modélisant des réseaux sociaux des algorithmes énumérant des communautés (c’est à dire des ensembles de sommets densément connectés). Ce genre d’algorithme trouve de nombreuses applications pratiques, par exemple pour le ciblage publicitaire. On utilisera pour ce projet l’approche proposée dans l’article scientifique [1]. En particulier, soit un graphe <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span> avec <span class="math inline"><em>V</em></span> l’ensemble des sommets et <span class="math inline"><em>E</em></span> l’ensemble des arêtes de <span class="math inline"><em>G</em></span>. On représentera une communauté par une clique. Une clique de <span class="math inline"><em>G</em></span> est un ensemble <span class="math inline"><em>K</em></span> de sommets du graphe tous connectés deux à deux. La clique <span class="math inline"><em>K</em></span> est maximale s’il n’existe pas de sommet dans <span class="math inline"><em>V</em> ∖ <em>K</em></span> connecté à tous les sommets de <span class="math inline"><em>K</em></span>. Le problème que l’on considère est d’énumérer toutes les cliques maximales d’un graphe. Dans un premier temps, vous implémenterez les deux algorithmes séquentiels présentés dans [1]. Ces algorithmes sont paramétrés par la dégénérescence du graphe en entrée, qu’il vous faudra calculer. Vous utiliserez l’algorithme de Bron-Kerbosch comme sous routine d’énumération. Dans un second temps, vous chercherez à paralléliser ces algorithmes. Dans toutes les étapes du projet on attendra que les algorithmes soient présentés théoriquement, puis comparés sur différentes instances en terme de temps et d’espace d’exécution.</p>
<p>Références:</p>
<p>[1] Manoussakis, A new decomposition technique for maximal clique enumeration for sparse graphs, theoretical computer science.</p>
<h2 id="analyseur-de-codes-génétiques">2) Analyseur de codes génétiques</h2>
<ul>
<li>Encadrant: Salah Ibnamar</li>
<li>E-Mail: &lt; mohammed TIRET salah POINT ibnamar ARROBASE uvsq.fr &gt;</li>
</ul>
<p>Le projet consiste à développer un analyseur de larges codes génétiques (séquences d’ADN de plusieurs gigaoctets). Les tâches principales seront relatives à la compression/encodage des donées, la transcription d’ADN en ARN, ainsi que la traduction de la séquence d’ARN en chaînes d’acides aminés (protéine). À ces tâches s’ajouteront la détection d’alignements, l’extraction de gênes (zones codantes), la détections de zones prones aux mutations et autres analyses.</p>
<p>Ce projet devra être implémenté entièrement en C avec vectorization et parallélisation manuelle (PThreds ou OpenMP) des zones à tâches critiques. Les tests de performance devront être réalisés en utilisant les compilateurs suivants: Intel Compiler, GCC, LLVM Clang. Il faudra fournir une analyse des performances des zones à tâches critiques et justifier du choix des optimisations choisies.</p>
<h2 id="réseau-de-neurones-à-convolution-reconaissance-dimages">3) Réseau de Neurones à Convolution (reconaissance d’images)</h2>
<ul>
<li>Encadrant: Salah Ibnamar</li>
<li>E-Mail: &lt; mohammed TIRET salah POINT ibnamar ARROBASE uvsq.fr &gt;</li>
</ul>
<p>Implémenter un réseau de neurones à convolutions que devra être entraîner sur le jeu d’images classifiées suivant [2] et dont la tâche sera de détecter dans des images données des tumeurs cancéreuses.</p>
<p>Référence:</p>
<p>[1] <a href="https://www.sciencedirect.com/science/article/pii/S2405959518304934">https://www.sciencedirect.com/science/article/pii/S2405959518304934</a></p>
<p>[2] <a href="https://www.kaggle.com/paultimothymooney/breast-histopathology-images">jeu de données</a></p>
<h2 id="calcul-de-densité-détat-de-particule-pour-la-modélisation-de-nanoparticule-à-transition-de-spin-sco-selon-un-modèle-dising.">4) Calcul de densité d’état de particule pour la modélisation de nanoparticule à transition de spin (SCO) selon un modèle d’Ising.</h2>
<ul>
<li>Encadrants: Thomas Dufaud, Devan Sohier</li>
<li>E-Mails: &lt; thomas POINT dufaud ARROBASE uvsq.fr &gt;, &lt; devan POINT sohier ARROBASE uvsq.fr &gt;</li>
</ul>
<p>Soit une particule composée de n atomes. Le calcul de densité d’état à une complexité de <span class="math inline">2<sup><em>n</em></sup></span>. Afin de modéliser une nano-particule SCO, les physiciens peuvent utiliser des techniques de Monte Carlo. Ainsi la méthode la plus couramment utilisée est la méthode de Monte-Carlo Metropolis. Celle-ci approche directement les quantités physiques souhaitées telle que la température pour une particule en fonction d’autres paramètres.</p>
<p>Une autre technique consiste à approcher la densité d’état de la particule par la technique de Monte Carlo Entropic Sampling [1,2] et ainsi pouvoir calculer directement une quantité physique quelque soit les paramètres de l’équation.</p>
<p>Dans le cas de particule 1D ou 2D (<span class="math inline"><em>n</em> = <em>n</em>1 × <em>n</em>2</span>) dont les atomes sont disposés sur une grille cartésienne, Il est possible de calculer la densité d’état de manière exacte avec une complexité de <span class="math inline"><em>n</em>1<sup>(7/2)</sup> * 2<sup><em>n</em>2</sup></span> au lieu de <span class="math inline">2<sup>(<em>n</em>1 × <em>n</em>2)</sup></span> . Dans [3,4] cette technique a été employée et permet une plus grande précision pour le calcul des quantités physiques..</p>
<p>Dans ce projet nous nous intéressons à la technique de Monte-Carlo Entropic Sampling pour approcher la densité d’état. L’objectif est de comparer cette technique d’approximation en terme de précision numérique et de complexité arithmétique avec la méthode de programmation dynamique employée dans [3,4]. La parallélisation de cette méthode et ces performances seront discutées au second semestre.</p>
<p>Mots clefs : méthode de Monte Carlo, Spin crossover nano particle, programmation dynamique</p>
<p>Langage : C Outils pour la parallélisation (S2): MPI, OMP4</p>
<p>Pré-requis : programmation C, algorithmique, Anglais</p>
<p>References:</p>
<p>[1] I. Sheto, J. Linares, F. Varret, Monte Carlo entropic sampling for the study of metastable states and relaxation paths, Physical review E, 1997, 56</p>
<p>[2] J. Linares, C. Enachescu, K. Boukheddaden, F. Varret, Monte Carlo entropic sampling applied to spin crossover solids: the squareness of the thermal hysteresis loop, Polyhedron, 2003, 22, 14-17, 2453–2456, Elsevier Science</p>
<p>[3] S-E. Allal, C. Harlé, D. Sohier, T. Dufaud, P-R. Dahoo, and J.Linares, Three Stable States Simulated for 1D Spin-Crossover Nanoparticles Using the Ising-Like Model, European Journal of Inorganic Chemistry, 2017, 36, http://dx.doi.org/10.1002/ejic.201700598}, 4196–4201, 2017</p>
<p>[4] C. Harlé et al. Numerical Investigations of the Thermal, Pressure and Size Effects on 2D Spin Crossover Nanoparticles December 2017Journal of Physics Conference Series 936(1):012061 DOI10.1088/1742-6596/936/1/012061</p>
<h2 id="utilisation-et-analyse-critique-des-rapports-maqao-pour-optimiser-des-mini-apps">5) Utilisation et analyse critique des rapports MAQAO pour optimiser des mini-apps</h2>
<ul>
<li>Encadrants: Emmanuel Oseret, Cédric Valensi</li>
<li>E-Mails: &lt; emmanuel POINT oseret AROBASE uvsq.fr &gt;, &lt; cedric POINT valensi AROBASE uvsq.fr &gt;</li>
</ul>
<p>Utiliser MAQAO pour analyser et optimiser des applications sous Linux. En particulier :</p>
<ul>
<li><p>Analyser à l’aide de MAQAO les applications proposée, pour différentes versions de compilateurs (en particulier récents) et si possible différentes architectures</p></li>
<li><p>Utiliser les informations fournies par les rapports MAQAO pour guider des modifications itératives du code et/ou de la chaîne de compilation</p></li>
<li><p>Valider les speed-ups obtenus par rapports aux prédictions de MAQAO</p></li>
<li><p>Évaluer la pertinence et l’utilité des informations fournies par MAQAO et proposer des corrections/améliorations/remarques pour l’outil</p></li>
</ul>
<p>Au premier semestre l’accent sera mis sur les aspects single-thread puis, au second semestre, sur les aspects parallèles (multithreads ou/et multiprocessus).</p>
<p>Référence : <a href="http://www.maqao.org" class="uri">http://www.maqao.org</a></p>
<h2 id="conversion-automatique-des-codes-de-calcul-hpc-en-virgule-flottante-vers-la-virgule-fixe">6) Conversion automatique des codes de calcul HPC en virgule flottante vers la virgule fixe</h2>
<ul>
<li>Encadrants: Matei Istoan</li>
<li>E-Mails: &lt; matei POINT istoan AROBASE uvsq.fr &gt;</li>
</ul>
<p>Ce projet propose d’explorer les améliorations de performance des codes HPC a travers la conversion des données numériques en virgule flottante vers la virgule fixe. La virgule flottante essaye d’approximer les nombres réels avec une représentation qui consiste du signe, un exposant (qui donne la magnitude) et une mantisse (qui donne la précision). D’une certaine manière, un nombre flottant peut être vu comme un entier (la valeur duquel est donne par la mantisse) décalé sur l’axe des nombres par un facteur dont la valeur est calcule a l’aide de l’exposant. Dans une représentation virgule fixe, on décide a l’avance quelle partie du format représente la partie entière, et quelle partie représente la partie fractionnaire. Par contraste avec la virgule flottante, un nombre en virgule fixe peut être vu comme un entier décalé d’un facteur qui est, du coup, fixe au moment du choix du format.</p>
<p>Dans les codes du calcul HPC on préfère souvent un implémentation en virgule flottante, grâce aux avantages qu’elle apporte: une gestion facile facile de la précision des calculs et une gestion facile de la dynamique des données. Par contre, ces avantages viennent au coût d’un impact en terme des performances, que ça soit le temps de calcul ou la consommation d’énergie. Une implémentation en virgule fixe peut apporter des améliorations en terme de performance. Mais un mauvais choix de format peut causer des problèmes de dépassement de capacité ou de perte de précision, qui peuvent, ensuite, causer des erreurs dans les résultats.</p>
<p>Le projet Verificarlo ([1]) propose l’étude de la stabilité numérique des code. Par ses différents modes de fonctionnement, a base des méthodes Monte-Carlo([2]), on peut étudier les effets des erreurs dans les programmes. Dans ce projets les étudiants vont premièrement étudier les effets d’une conversion du flottant vers fixe, a travers la simulations du code en virgule fixe. Ceci implique la création d’un nouveau backend pour Verificarlo. Par la suite, les étudiants vont analyser les gains de performance qui sont possible, suite a la conversion automatique des codes.</p>
<p>Références :</p>
<p>[1] Verificarlo: Checking Floating Point Accuracy through Monte Carlo Arithmetic. Christophe Denis, Pablo de Oliveira Castro, and Eric Petit. In 23nd IEEE Symposium on Computer Arithmetic, ARITH 2016, Silicon Valley, CA, USA, July 10-13, 2016, pages 55–62, 2016.</p>
<p>[2] Parker, D. Stott, Brad Pierce, and Paul R. Eggert. “Monte Carlo arithmetic: how to gamble with floating point and win.” Computing in Science &amp; Engineering 2.4 (2000): 58.</p>
<h2 id="support-mpi-dans-verificarlo">7) Support MPI dans Verificarlo</h2>
<ul>
<li>Encadrants: Éric Petit</li>
<li>E-Mails: &lt; eric POINT petit AROBASE uvsq.fr &gt;</li>
</ul>
<p>Le logiciel open-source Verificarlo: https://github.com/verificarlo/verificarlo est le fruit d’une collaboration entre l’UVSQ, Intel, le CEA et d’autres contributeurs. Cet outil permet, par instrumentation au niveau compilateur, d’intercepter toutes les operation en virgule flottante d’un programme pour en faire l’analyse, par trace, profil ou modification du comportement. Ceci nous permet dans le cadre d’applications de simulation numérique de debugger, valider, et optimiser l’utilisation des nombres flottants et leur format (simple, double, demi…).</p>
<p>Lors de précedentes analyses, un prototype du support de MPI pour les codes distribués a été fait, mais n’a jamais atteint un stade de maturité suffisant pour etre distribué. Par ailleurs le support des codes multithreadés, en particulier par OpenMP, et vectorisés necessite aujourd’hui la sérialisation des opérations induisant un surcout qui restreint notre champ d’expérimentation. Afin de supporter le parallélisme en mémoire partagé, il faudra développer des opérateurs vectorisés dans Verificarlo pour les deux principaux outils d’analyse, MCA et Vprec, ainsi que s’assurer de leur aspect thread-safe. Ceci comprend la géneration de nombres aléatoires indépendants pour MCA, et la gestion des entrées sorties. Enfin, ces outils en place il sera possible de commencer l’étude de l’impact des environnements d’exécution MPI et openMP sur la stabilité des codes et proposer de nouvelles analyses pour les utilisateurs.</p>
<h2 id="différentiation-automatique">8) Différentiation Automatique</h2>
<ul>
<li>Encadrants: Pablo Oliveira</li>
<li>E-Mails: &lt; pablo POINT oliveira AROBASE uvsq.fr &gt;</li>
</ul>
<p>Les méthodes de différentiation automatique (DA) permettent de calculer la dérivée de fonctions au sein d’un programme. Elle se basent sur une décomposition de la fonction en un graphe d’opérations élémentaires. En appliquant les règles de dérivation des fonctions composées, il est possible de décomposer le calcul de la dérivée sur chacune des opérations du programme.</p>
<p>Les méthodes de différences finies permettent également de dériver numériquement une fonction. Elles ont néanmoins deux inconvénients:</p>
<ul>
<li><p>pour des fonctions avec de multiples entrées, calculer la dérivée partielle pour chacune des entrées nécessite de multiples exécutions.</p></li>
<li><p>pour des fonctions complexes les méthodes de différences finies ne sont pas toujours précises numériquement en raison d’erreurs d’arrondi, en particulier pour des dérivées d’ordre supérieur</p></li>
</ul>
<p>Au contraire les méthodes de DA limitent les erreurs car le calcul de la dérivée se fait opérateur par opérateur; et le mode « vers l’arrière » permet d’obtenir l’ensemble des dérivées partielles en une seule passe (au prix d’une complexité spatiale accrue).</p>
<p>Dans ce projet vous explorerez les méthodes de DA.</p>
<ol type="1">
<li><p>Vous ferez un état de l’art sur les méthodes de différentiation automatique. Quelques ressources accessibles [1], [2], [3].</p></li>
<li><p>Vous implémenterez une bibliothèque de DA avec les modes « vers l’avant » et « vers l’arrière » dans le langage de votre choix. Vous choisirez de préférence un langage permettant l’utilisation de macros (C++, Python, Scala, Lisp, Julia, Haskell, etc.)</p></li>
<li><p>Vous montrerez l’utilité de votre bibliothèque sur une application classique. Par exemple, dans le cadre de la retro-propagation du gradient.</p></li>
</ol>
<p>Vous pourrez également (de manière optionnelle) explorer d’autres aspects plus avancés:</p>
<ol start="4" type="1">
<li>L’intégration de la DA directement dans le compilateur (eg. [3])</li>
</ol>
<p>Références:</p>
<p>[1] <a href="https://medium.com/@marksaroufim/automatic-differentiation-step-by-step-24240f97a6e6">Automatic differentiation step by step</a></p>
<p>[2] <a href="https://rufflewind.com/2016-12-30/reverse-mode-automatic-differentiation">https://rufflewind.com/2016-12-30/reverse-mode-automatic-differentiation</a></p>
<p>[3] <a href="https://github.com/MikeInnes/diff-zoo">https://github.com/MikeInnes/diff-zoo</a></p>
<p>[4] <a href="https://enzyme.mit.edu/">https://enzyme.mit.edu/</a></p>
</body>
</html>
