
<dl>

<dt>
<a name="Kiar2021Numerical">&nbsp;</a>
</dt>
<dd>
<b>Numerical uncertainty in analytical pipelines lead to impactful
  variability in brain networks</b>.
 Gregory Kiar, Yohan Chatelain, Pablo de&nbsp;Oliveira&nbsp;Castro, Eric Petit,
  Ariel Rokem, Gaël Varoquaux, Bratislav Misic, Alan&nbsp;C. Evans, and Tristan
  Glatard.
 <em>PLOS ONE</em>, 16(11):1--16, 11 2021.
[&nbsp;<a href="arithmetic_bib.html#Kiar2021Numerical">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1371/journal.pone.0250755">DOI</a>&nbsp;| 
<a href="https://doi.org/10.1371/journal.pone.0250755">http</a>&nbsp;]
<blockquote><font size="-1">
The analysis of brain-imaging data requires complex processing pipelines to support findings on brain function or pathologies. Recent work has shown that variability in analytical decisions, small amounts of noise, or computational environments can lead to substantial differences in the results, endangering the trust in conclusions. We explored the instability of results by instrumenting a structural connectome estimation pipeline with Monte Carlo Arithmetic to introduce random noise throughout. We evaluated the reliability of the connectomes, the robustness of their features, and the eventual impact on analysis. The stability of results was found to range from perfectly stable (i.e. all digits of data significant) to highly unstable (i.e. 0 − 1 significant digits). This paper highlights the potential of leveraging induced variance in estimates of brain connectivity to reduce the bias in networks without compromising reliability, alongside increasing the robustness and potential upper-bound of their applications in the classification of individual differences. We demonstrate that stability evaluations are necessary for understanding error inherent to brain imaging experiments, and how numerical analysis can be applied to typical analytical workflows both in brain imaging and other domains of computational sciences, as the techniques used were data and context agnostic and globally relevant. Overall, while the extreme variability in results due to analytical instabilities could severely hamper our understanding of brain organization, it also affords us the opportunity to increase the robustness of findings.
</font></blockquote>

</dd>


<dt>
<a name="Sohier2021Confidence">&nbsp;</a>
</dt>
<dd>
<b>Confidence Intervals for Stochastic Arithmetic</b>.
 Devan Sohier, Pablo de&nbsp;Oliveira&nbsp;Castro, Fran&#x00E7;ois F&eacute;votte,
  Bruno Lathuili&egrave;re, Eric Petit, and Olivier Jamond.
 <em>ACM Transactions Mathematical Software</em>, 47(2), April 2021.
[&nbsp;<a href="arithmetic_bib.html#Sohier2021Confidence">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1145/3432184">DOI</a>&nbsp;| 
<a href="https://doi.org/10.1145/3432184">http</a>&nbsp;| 
<a href="https://hal.archives-ouvertes.fr/hal-01827319/file/confidence.pdf">.pdf</a>&nbsp;| 
<a href="confidence_interval_slides.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
Quantifying errors and losses due to the use of Floating-point (FP) calculations in industrial scientific computing codes is an important part of the Verification, Validation, and Uncertainty Quantification process. Stochastic Arithmetic is one way to model and estimate FP losses of accuracy, which scales well to large, industrial codes. It exists in different flavors, such as CESTAC or MCA, implemented in various tools such as CADNA, Verificarlo, or Verrou. These methodologies and tools are based on the idea that FP losses of accuracy can be modeled via randomness. Therefore, they share the same need to perform a statistical analysis of programs results to estimate the significance of the results.In this article, we propose a framework to perform a solid statistical analysis of Stochastic Arithmetic. This framework unifies all existing definitions of the number of significant digits (CESTAC and MCA), and also proposes a new quantity of interest: the number of digits contributing to the accuracy of the results. Sound confidence intervals are provided for all estimators, both in the case of normally distributed results, and in the general case. The use of this framework is demonstrated by two case studies of industrial codes: Europlexus and code_aster.
</font></blockquote>

</dd>


<dt>
<a name="Defour2021Shadow">&nbsp;</a>
</dt>
<dd>
<b>Shadow computation with BFloat16 to compute numerical accuracy</b>.
 David Defour, Pablo De&nbsp;Oliveira&nbsp;Castro, Matei Istoan, and Eric Petit.
 In <em>IEEE 28th Symposium on Computer Arithmetic (ARITH)</em>, June
  2021.
[&nbsp;<a href="arithmetic_bib.html#Defour2021Shadow">bib</a>&nbsp;| 
<a href="https://hal.archives-ouvertes.fr/hal-03159965v2/">http</a>&nbsp;]

</dd>


<dt>
<a name="Brun2021Study">&nbsp;</a>
</dt>
<dd>
<b>A Study of the Effects and Benefits of Custom-Precision Mathematical
  Libraries for HPC Codes</b>.
 E.&nbsp;Brun, D.&nbsp;Defour, P.&nbsp;De Oliveira Castro, M.&nbsp;Istoan,
  D.&nbsp;Mancusi, E.&nbsp;Petit, and A.&nbsp;Vaquet.
 <em>IEEE Transactions on Emerging Topics in Computing</em>,
  9(3):1467--1478, 2021.
[&nbsp;<a href="arithmetic_bib.html#Brun2021Study">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1109/TETC.2021.3070422">DOI</a>&nbsp;]
<blockquote><font size="-1">
Mathematical libraries are being specifically developed to use fixed-width data-paths on processors and target common floating-point formats like binary32 and binary64. In this article we propose a framework to evaluate the effects of mathematical library calls accuracy in scientific computations. First, our tool collects for each call-site of a mathematical function the input-data profile. Then, using a heuristic exploration algorithm, we estimate the minimal required accuracy by rounding the result to lower precisions. The data profile and accuracy measurement per call-site is used to speculatively select the mathematical function implementation with the most appropriate accuracy for a given scenario. We have tested the methodology with the Intel MKL VML library with predefined accuracy levels. We demonstrate the benefits of our approach on two real-world applications: SGP4, a satellite tracking application, and PATMOS, a Monte Carlo neutron transport code. We experiment and discuss its generalization across data-sets, and finally propose a speculative runtime implementation for PATMOS. The experiment provides an insight into the performance improvements that can be achieved by leveraging the control of per-function call-site accuracy-mode execution of the Intel MKL VML library.
</font></blockquote>

</dd>


<dt>
<a name="Kiar2020Comparing">&nbsp;</a>
</dt>
<dd>
<b>Comparing perturbation models for evaluating stability of neuroimaging
  pipelines</b>.
 Gregory Kiar, Pablo de&nbsp;Oliveira&nbsp;Castro, Pierre Rioux, Eric Petit,
  Shawn&nbsp;T Brown, Alan&nbsp;C Evans, and Tristan Glatard.
 <em>The International Journal of High Performance Computing
  Applications</em>, 34(5):491--501, 2020.
[&nbsp;<a href="arithmetic_bib.html#Kiar2020Comparing">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1177/1094342020926237">DOI</a>&nbsp;| 
<a href=" https://doi.org/10.1177/1094342020926237 ">www:</a>&nbsp;| 
<a href="https://youtu.be/TymQQJ6iYRQ">http</a>&nbsp;]
<blockquote><font size="-1">
 With an increase in awareness regarding a troubling lack of reproducibility in analytical software tools, the degree of validity in scientific derivatives and their downstream results has become unclear. The nature of reproducibility issues may vary across domains, tools, data sets, and computational infrastructures, but numerical instabilities are thought to be a core contributor. In neuroimaging, unexpected deviations have been observed when varying operating systems, software implementations, or adding negligible quantities of noise. In the field of numerical analysis, these issues have recently been explored through Monte Carlo Arithmetic, a method involving the instrumentation of floating-point operations with probabilistic noise injections at a target precision. Exploring multiple simulations in this context allows the characterization of the result space for a given tool or operation. In this article, we compare various perturbation models to introduce instabilities within a typical neuroimaging pipeline, including (i) targeted noise, (ii) Monte Carlo Arithmetic, and (iii) operating system variation, to identify the significance and quality of their impact on the resulting derivatives. We demonstrate that even low-order models in neuroimaging such as the structural connectome estimation pipeline evaluated here are sensitive to numerical instabilities, suggesting that stability is a relevant axis upon which tools are compared, alongside more traditional criteria such as biological feasibility, computational efficiency, or, when possible, accuracy. Heterogeneity was observed across participants which clearly illustrates a strong interaction between the tool and data set being processed, requiring that the stability of a given tool be evaluated with respect to a given cohort. We identify use cases for each perturbation method tested, including quality assurance, pipeline error detection, and local sensitivity analysis, and make recommendations for the evaluation of stability in a practical and analytically focused setting. Identifying how these relationships and recommendations scale to higher order computational tools, distinct data sets, and their implication on biological feasibility remain exciting avenues for future work. 
</font></blockquote>

</dd>


<dt>
<a name="Defour2020CustomPrecision">&nbsp;</a>
</dt>
<dd>
<b>Custom-Precision Mathematical Library Explorations for Code Profiling and
  Optimization</b>.
 David Defour, Pablo de&nbsp;Oliveira&nbsp;Castro, Matei Istoan, and Eric Petit.
 In <em>27th IEEE Symposium on Computer Arithmetic, ARITH 2020</em>,
  pages 121--124, 2020.
[&nbsp;<a href="arithmetic_bib.html#Defour2020CustomPrecision">bib</a>&nbsp;| 
<a href="https://hal.archives-ouvertes.fr/hal-02563852/document">http</a>&nbsp;]
<blockquote><font size="-1">
The typical processors used for scientific computing have fixed-width data-paths. This implies that mathematical libraries were specifically developed to target each of these fixed precisions (binary16, binary32, binary64). However, to address the increasing energy consumption and throughput requirements of scientific applications, library and hardware designers are moving beyond this one-size-fits-all approach. In this article we propose to study the effects and benefits of using user-defined floating-point formats and target accuracies in calculations involving mathematical functions. Our tool collects input-data profiles and iteratively explores lower precisions for each call-site of a mathematical function in user applications. This profiling data will be a valuable asset for specializing and fine-tuning mathematical function implementations for a given application. We demonstrate the tool's capabilities on SGP4, a satellite tracking application. The profile data shows the potential for specialization and provides insight into answering where it is useful to provide variable-precision designs for elementary function evaluation.
</font></blockquote>

</dd>


<dt>
<a name="Chatelain2019automatic">&nbsp;</a>
</dt>
<dd>
<b>Automatic exploration of reduced floating-point representations in
  iterative methods</b>.
 Yohan Chatelain, Eric Petit, Pablo de&nbsp;Oliveira&nbsp;Castro, Ghislain
  Lartigue, and David Defour.
 In <em>Euro-Par 2019 Parallel Processing - 25th International
  Conference</em>, Lecture Notes in Computer Science. Springer, 2019.
[&nbsp;<a href="arithmetic_bib.html#Chatelain2019automatic">bib</a>&nbsp;| 
<a href="dyn_adapt_precision19.pdf">.pdf</a>&nbsp;| 
<a href="dyn_adapt_slides19.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
With the ever-increasing need for computation of scientific applications, new application domains, and major energy constraints, the landscape of floating-point computation is changing.  New floating-point representation formats are emerging and there is a need for tools to simulate their impact in legacy codes.  In this paper, we propose an automatic tool to evaluate the effect of adapting the floating point precision for each operation over time, which is particularly useful in iterative schemes.  We present a backend to emulate any IEEE-754 floating-point operation in lower precision.  We tested the numerical errors resilience of our solutions thanks to Monte Carlo Arithmetic and  demonstrated the effectiveness of this methodology on YALES2, a large Combustion-CFD HPC code, by achieving 28% to 67% reduction in communication volume by lowering precision.
</font></blockquote>

</dd>


<dt>
<a name="Chatelain2018veritracer">&nbsp;</a>
</dt>
<dd>
<b>VeriTracer: Context-enriched tracer for floating-point arithmetic
  analysis</b>.
 Yohan Chatelain, Pablo de&nbsp;Oliveira&nbsp;Castro, Eric Petit, David Defour,
  Jordan Bieder, and Marc Torrent.
 In <em>25th IEEE Symposium on Computer Arithmetic, ARITH 2018,
  Amherst, MA, USA. June 25th-27th, 2018</em>, pages 65--72. IEEE, 2018.
[&nbsp;<a href="arithmetic_bib.html#Chatelain2018veritracer">bib</a>&nbsp;| 
<a href="arith2018veritracer.pdf">.pdf</a>&nbsp;| 
<a href="arith2018slides.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
VeriTracer automatically instruments a code and
    traces the accuracy of floating-point variables over
    time. VeriTracer enriches the visual traces with contextual
    information such as the call site path in which
    a value was modified. Contextual information is important
    to understand how the floating-point errors
    propagate in complex codes. VeriTracer is implemented
    as an LLVM compiler tool on top of Verificarlo.
    We demonstrate how VeriTracer can detect accuracy
    loss and quantify the impact of using a compensated
    algorithm on ABINIT, an industrial HPC application
    for Ab Initio quantum computation.
</font></blockquote>

</dd>


<dt>
<a name="Denis2016verificarlo">&nbsp;</a>
</dt>
<dd>
<b>Verificarlo: Checking Floating Point Accuracy through Monte Carlo
  Arithmetic</b>.
 Christophe Denis, Pablo de&nbsp;Oliveira&nbsp;Castro, and Eric Petit.
 In <em>23nd IEEE Symposium on Computer Arithmetic, ARITH 2016,
  Silicon Valley, CA, USA, July 10-13, 2016</em>, pages 55--62, 2016.
[&nbsp;<a href="arithmetic_bib.html#Denis2016verificarlo">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1109/ARITH.2016.31">DOI</a>&nbsp;| 
<a href="http://dx.doi.org/10.1109/ARITH.2016.31">http</a>&nbsp;| 
<a href="https://hal.archives-ouvertes.fr/hal-01192668/file/verificarlo-preprint.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
Numerical accuracy of floating point computation is a well studied topic which has not made its way to the end-user in scientific computing. Yet, it has become a critical issue with the recent requirements for code modernization to harness new highly parallel hardware and perform higher resolution computation. To democratize numerical accuracy analysis, it is important to propose tools and methodologies to study large use cases in a reliable and automatic way. In this paper, we propose verificarlo, an extension to the LLVM compiler to automatically use Monte Carlo Arithmetic in a transparent way for the end-user. It supports all the major languages including C, C++, and Fortran. Unlike source-to-source approaches, our implementation captures the influence of compiler optimizations on the numerical accuracy. We illustrate how Monte Carlo Arithmetic using the verificarlo tool outperforms the existing approaches on various use cases and is a step toward automatic numerical analysis.
</font></blockquote>

</dd>
</dl>