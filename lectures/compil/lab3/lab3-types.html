<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Lab 3 (second part) - Type checker</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../pandoc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Lab 3 (second part) - Type checker</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#setup">Setup</a></li>
<li><a href="#adding-the-type-checker-file-and-command-line-argument">Adding the type checker file and command-line argument</a></li>
<li><a href="#implementing-the-type-checker">Implementing the type checker</a></li>
<li><a href="#note-on-automated-test-results">Note on automated test results</a></li>
<li><a href="#optional-implementing-the-escaper">Optional: implementing the escaper</a></li>
</ul>
</nav>
<p>In this lab we will write a type checker for our tiger compiler. The type checker is responsible for the following tasks:</p>
<ul>
<li>assigning types to expressions and declarations lacking them;</li>
<li>checking types consistency.</li>
</ul>
<p>For example, after running the typer, the expression</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode tiger"><code class="sourceCode tiger"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">let</span> <span class="kw">var</span> a <span class="op">:=</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="kw">var</span> b <span class="op">:=</span> a</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">in</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="kw">let</span> <span class="kw">var</span> c <span class="op">:=</span> a <span class="op">+</span> b <span class="kw">in</span> <span class="fu">print_int</span>(c) <span class="kw">end</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">end</span></a></code></pre></div>
<p>will be typed as <em>void</em> and will be displayed as</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode tiger"><code class="sourceCode tiger"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">function</span> main()<span class="op">:</span> <span class="dt">int</span> <span class="op">=</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  (</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="kw">let</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">      <span class="kw">var</span> a<span class="op">:</span> <span class="dt">int</span> <span class="op">:=</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">      <span class="kw">var</span> b<span class="op">:</span> <span class="dt">int</span> <span class="op">:=</span> a</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    <span class="kw">in</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">      <span class="kw">let</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">        <span class="kw">var</span> c<span class="op">:</span> <span class="dt">int</span> <span class="op">:=</span> (a <span class="op">+</span> b)</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">      <span class="kw">in</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">        <span class="fu">print_int</span>(c)</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">      <span class="kw">end</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">    <span class="kw">end</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13">    <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14">  )</a></code></pre></div>
<h2 id="setup">Setup</h2>
<p>You will work in the same directory as the first part of lab 3. You do not need to retrieve and unpack an archive for this part.</p>
<p>You do not need to do any particular setup.</p>
<h2 id="adding-the-type-checker-file-and-command-line-argument">Adding the type checker file and command-line argument</h2>
<p>The type checker is a visitor similar to the binder. It <strong>must</strong> be located in <code>src/ast/type_checker.hh</code> (and <code>src/ast/type_checker.cc</code> if needed, which will probably the case) in order to be picked up by the automated grader.</p>
<p>You must add a <code>--type/-t</code> command to the driver which will run your AST tree through the type checker. Once you have added this command like argument, the <code>--help</code> output should look like:</p>
<pre><code>$ src/driver/dtiger --help
Options:
  -h [ --help ]         describe arguments
  --dump-ast            dump the parsed AST
  -b [ --bind ]         run the binder on the parsed AST
  -t [ --type ]         run the type checker on the parsed AST
  --trace-parser        enable parser traces
  --trace-lexer         enable lexer traces
  -v [ --verbose ]      be verbose
  --input-file arg      input Tiger file</code></pre>
<p>The binder must be run before the type checker even if the user does not explicitly give <code>--bind</code> on the command line, as it makes no sense to type check the tree if it has not been decorated.</p>
<p>Also, in order to see the results of the type checker, the dump of the AST (if requested) must take place after the type checker has run.</p>
<p>For interoperability purpose with later labs, the class of the type checker must be <code>TypeChecker</code> and be declared in namespace <code>ast::type_checker</code>.</p>
<h2 id="implementing-the-type-checker">Implementing the type checker</h2>
<p>The type checker must perform the following operations:</p>
<ul>
<li><code>IntegerLiteral</code> and <code>StringLiteral</code> nodes are given respectively the <code>t_int</code> and <code>t_string</code> types.</li>
<li><code>Sequence</code> nodes have the same type as their last expression if they have one, otherwise they are <code>t_void</code>.</li>
<li><code>IfThenElse</code> nodes must have type-compatible branches, whose type become their type.</li>
<li><code>Let</code> expressions have the same type as their last expression if they have one, otherwise they are <code>t_void</code>.</li>
<li><code>VarDecl</code> nodes without an explicit type (in the <code>type_name</code> field) take their type from their expression. This type cannot be <code>t_void</code> since a variable is either an integer or a string.</li>
<li><code>VarDecl</code> nodes with an explicit type given in the source must check that the expression (if any) is compatible with this type, which will become the type of the node.</li>
<li><code>BinaryOperator</code> nodes must check that their arguments have types compatible with the operation and with each other, and set the resulting type.</li>
<li><code>Identifier</code> nodes inherit the type of their declaration.</li>
<li><code>Assign</code> nodes must check the validity of the assignment and be <code>t_void</code> themselves.</li>
<li><code>WhileLoop</code> nodes must have integer conditions and a body of type <code>t_void</code>, and are themselves <code>t_void</code>.</li>
<li><code>ForLoop</code> nodes must have integer bounds, an integral index, and a body of type <code>t_void</code>, and are themselves <code>t_void</code>.</li>
<li><code>Break</code> nodes are <code>t_void</code>.</li>
<li><code>FunDecl</code> nodes have either an explicit type (in the <code>type_name</code> field) which matches the type of their expression, or no explicit type in which case their expression and themselves must be <code>t_void</code>.</li>
<li><code>FunCall</code> nodes inherit the type of their declaration. The type checker also ensures that number of arguments matches the number of parameters, and that they all have the right type.</li>
</ul>
<p>Note that in some cases you might analyze a <code>FunCall</code> targeting a <code>FunDecl</code> which has not yet been analyzed. It may happen in two cases:</p>
<ul>
<li>you are calling a primitive function, and primitives are not located in the tree;</li>
<li>you are calling a function defined after the current one in the same declarative block (mutually recursive functions).</li>
</ul>
<p>In those cases, you might note that the target has not been analyzed because its type is still <code>t_undef</code>. When this happens, you should recurse and analyze the declaration of your target.</p>
<p>It also mean that before analyzing a <code>FunDecl</code> you must make sure that it has not been analyzed yet, as it may have been analyzed during the processing of a <code>FunCall</code> in the second case described above. In this case, the visit of the <code>FunDecl</code> should not have any effect since it has been done already.</p>
<h2 id="note-on-automated-test-results">Note on automated test results</h2>
<p>Since by default the binder accepts anything without checking the types consistency, some type checker tests may appear to pass very early. This is due to the fact that some constructs are valid and will not be rejected. However, as you add more type checking, some tests that were passing may start to fail because you are rejecting valid constructs.</p>
<h2 id="optional-implementing-the-escaper">Optional: implementing the escaper</h2>
<p>This part will not be tested automatically, but must be implemented if you want to be able to use your own code in the next lab.</p>
<p>You need to build yet another visitor, the escaper, which will run right after the binder. Its role is, for every <code>VarDecl</code> which escapes (this flag has already been set by the binder), to add it to the current function <code>get_escaping_decls()</code> vector.</p>
<p>This is necessary so that when we build the frames for the functions, we can put the escaping variables in the frame structure (since they might be accessed from outside the function and need to be stored in memory), while other variables may be stored separately and put into registers as they will never be read or modified outside the function by nested functions.</p>
<p>So your work is simple:</p>
<ul>
<li>When visiting a <code>FunDecl</code> node, save the current function, set the current function to the one you are visiting, recurse, then restore the current function.</li>
<li>When visiting a <code>VarDecl</code> node, if it escapes, add it to the list of escaping declarations for the current functions (and recurse into its expression if any).</li>
<li>For every other node, recurse in case you encounter a <code>FunDecl</code> or <code>VarDecl</code> somewhere lower in the tree.</li>
</ul>
<p>For interoperability purpose with later labs, the class of the escaper must be <code>Escaper</code> and be declared in namespace <code>ast::escaper</code>.</p>
</body>
</html>
