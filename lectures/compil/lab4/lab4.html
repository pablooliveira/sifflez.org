<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Lab 4 - IR generation</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../pandoc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Lab 4 - IR generation</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#setup">Setup</a></li>
<li><a href="#important-note">Important note</a></li>
<li><a href="#assembly-production-and-ir-verification">Assembly production and IR verification</a></li>
<li><a href="#code-organization">Code organization</a></li>
<li><a href="#llvm-builder">LLVM Builder</a></li>
<li><a href="#variables">Variables</a></li>
<li><a href="#tests-and-branches">Tests and branches</a></li>
<li><a href="#loops">Loops</a></li>
</ul>
</nav>
<p>In this lab we will write a code generator for our Tiger compiler targeting LLVM IR.</p>
<p>The IR code generator is responsible for the following tasks:</p>
<ul>
<li>Creating a IR module in which functions will be defined.</li>
<li>Creating independent top-level IR functions for every Tiger function in the source code, including the nested ones.</li>
<li>Building stack frames to hold escaping variables, and giving pointer to the outer stack frame to every function called.</li>
<li>Building basic blocks to represent the flow of the Tiger function.</li>
</ul>
<p>A completed code generator should never raise an error related to the source code. All errors should have been caught in earlier phases already. For example, an unknown identifier would have been caught and reported by the binder. A typing inconsistency would have been caught and reported by the typer.</p>
<h2 id="setup">Setup</h2>
<p>Retrieve the lab code and commit it to your git with the following commands,</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1">$ <span class="fu">mkdir</span> lab4</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">$ <span class="bu">cd</span> lab4</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">$ <span class="fu">wget</span> -qO- www.sifflez.org/lectures/compil/lab4/dragon-tiger.tar.gz <span class="kw">|</span> <span class="fu">tar</span> zxv</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">$ <span class="fu">git</span> add -f dragon-tiger/</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">$ <span class="fu">git</span> commit -m <span class="st">&quot;Import dragon-tiger for lab4&quot;</span></a></code></pre></div>
<p>Now let us build the project,</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1">$ <span class="bu">cd</span> dragon-tiger</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">$ <span class="ex">./configure</span> --with-llvm=/usr/lib/llvm-3.9</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">$ <span class="fu">make</span></a></code></pre></div>
<p>If everything worked as expected, you should be able to run the compiler driver <code>dtiger</code> as follows,</p>
<pre><code>$ src/driver/dtiger --help
Options:
  -h [ --help ]         describe arguments
  --dump-ast            dump the parsed AST
  --dump-ir             dump the generated IR
  -b [ --bind ]         run the binder on the parsed AST
  -t [ --type ]         run the type checker on the parsed AST
  -i [ --irgen ]        run the LLVM IR code generator
  --trace-parser        enable parser traces
  --trace-lexer         enable lexer traces
  -v [ --verbose ]      be verbose
  --input-file arg      input Tiger file
  -o [ --object ] arg   generate object code file

$ echo &quot;print_int(42)&quot; &gt; test.tig
$ src/driver/dtiger -i --dump-ir test.tig
; ModuleID = &#39;tiger&#39;
source_filename = &quot;tiger&quot;

define i32 @main() {
entry:
  br label %body

body:                                             ; preds = %entry
  call void @__print_int(i32 42)
  ret i32 0
}

declare void @__print_int(i32)</code></pre>
<p>Ensure that you test thoroughly and commit each feature. Follow precisely the instructions, this lab is graded and machine corrected!</p>
<h2 id="important-note">Important note</h2>
<p>Some of you may not have completed the previous assignment. To this effect, the current archive contains a pre-built parser library (so as not to give you the full solution) and binder and type checker phase and this lab may be done separately.</p>
<p>However, when you have completed the previous assignment, feel free to replace the <code>src/parser/</code> directory by a copy of the one from your previous assignment. This will be most satisfactory, as your code from the first step will be used also in the second step. Do not forget to add <code>parser</code> to the <code>SUBDIRS</code> variable in <code>src/Makefile.am</code> (it must be the <strong>first</strong> subdirectory there because it auto-generates files used in other subdirectories) and in <code>src/parser/Makefile</code> in <code>configure.ac</code>.</p>
<p>You might also want to propagate your evaluator code although this will not be needed.</p>
<p>Similarly, you can get the <code>src/ast/</code> directory from the second lab as long as you have implemented the binder, type checker and escaper.</p>
<h2 id="assembly-production-and-ir-verification">Assembly production and IR verification</h2>
<p>Piping your IR output to the <code>llc</code> program (found in <code>/usr/lib/llvm-3.9/bin</code>) will tell you if there is a typing output in our IR (for example if you try to use a pointer instead of an integer), and will output Intel assembly code corresponding to the computer is it currently executing onto.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1">$ <span class="bu">export</span> <span class="va">PATH=</span>/usr/lib/llvm-3.9/bin:<span class="va">$PATH</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">$ <span class="ex">src/driver/dtiger</span> -i --dump-ir test.tig <span class="kw">|</span> <span class="ex">opt</span> -mem2reg <span class="kw">|</span> <span class="ex">llc</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">[…<span class="ex">intel</span> assembly output…]</a></code></pre></div>
<p>If you are more familiar with ARM Thumb-2 instruction set, you can obtain it by using <code>llc -march=arm -mcpu=cortex-m4</code> for example.</p>
<p>You can combine this with <code>opt -mem2reg</code> to see the effect of removing the unneeded <code>alloca</code> IR instructions:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" data-line-number="1">$ <span class="ex">src/driver/dtiger</span> -i --dump-ir test.tig <span class="kw">|</span> <span class="ex">opt</span> -mem2reg <span class="kw">|</span> <span class="ex">llc</span> -march=arm -mcpu=cortex-m4</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">[…<span class="ex">thumb2</span> assembly output…]</a></code></pre></div>
<h2 id="code-organization">Code organization</h2>
<p>The IR code generator is called with the <code>-i</code> option. It is interesting to also add the <code>--dump-ir</code> option which provides a text dump of the generated IR.</p>
<p>The declarations of the IR code generator can be found in <code>src/irgen/irgen.hh</code>. The implementation is split in two parts:</p>
<ul>
<li><code>src/irgen/irgen.cc</code> contains the code to generate new functions, stack frames, variable declarations, etc.</li>
<li><code>src/irgen/irgen-visitor.cc</code> contains the code to transform the AST into IR.</li>
</ul>
<p>For this lab, you are provided with an incomplete <code>src/irgen/irgen-visitor.cc</code> that you will have to fill according to the instructions. Each <code>visit</code> method must return a <code>llvm::Value *</code> which represents the result of the translated expression. If the expression (or statement) has no useful return value, <code>visit</code> must return <code>nullptr</code>.</p>
<h2 id="llvm-builder">LLVM Builder</h2>
<p>A LLVM IRBuilder object helps you insert code into a basic block. It remembers the block and the place within the block where it is currently inserting code (called the <em>insertion point</em>). Our <code>IRGenerator</code> class contains a <code>Builder</code> field for this purpose.</p>
<p>The IRBuilder contains a lot of methods designed to make code generation easier. For example, it can move the insertion point to the end of another basic block, it can generate a branch instruction to another block, or generate a conditional branch instruction to another block, etc.</p>
<ol class="example" type="1">
<li>Read carefully the provided code and make sure you understand how the visitor for the <code>Sequence</code> AST node works, both for a non-empty and an empty sequence.</li>
</ol>
<h2 id="variables">Variables</h2>
<ol start="2" class="example" type="1">
<li>Using utility methods declared in <code>irgen.hh</code>, implement the visitor for <code>VarDecl</code> nodes. Do not forget to initialize the variable content with its initial value if it has one. Look at the IRBuilder provided utility to store the initial value at the right address. Also, the <code>llvm::Value *</code> representing the variable address should be regsitered into the <code>allocations</code> map which maps variable declarations to their addresses.</li>
</ol>
<p>To validate your implementation, you can check that the following Tiger code</p>
<pre><code>let var a := 1 in end</code></pre>
<p>generates something like</p>
<pre><code>define i32 @main() {
entry:
  %a = alloca i32
  br label %body

body:                                             ; preds = %entry
  store i32 1, i32* %a
  ret i32 0
}</code></pre>
<p>One can clearly identify the allocation of a <code>i32</code> reserved space onto the stack (whose address is stored into <code>%a</code>) in the entry block of the main function. In the body, the initial value <code>1</code> is stored at address <code>%a</code>.</p>
<ol start="3" class="example" type="1">
<li>Implement the visitor for <code>Identifier</code> nodes.</li>
</ol>
<p>The following code</p>
<pre><code>let var a := 1 in print_int(a) end</code></pre>
<p>should now also contain something like:</p>
<pre><code>  %0 = load i32, i32* %a
  call void @__print_int(i32 %0)</code></pre>
<p>showing that the value stored at <code>%a</code> has been read into <code>%0</code> and then passed to function <code>print_int</code>.</p>
<ol start="4" class="example" type="1">
<li>Implement the visitor for <code>Assign</code> nodes.</li>
</ol>
<p>The following code</p>
<pre><code>let var a := 1 in a := 3; print_int(a) end</code></pre>
<p>should now also contain something like:</p>
<pre><code>  store i32 1, i32* %a
  store i32 3, i32* %a
  %0 = load i32, i32* %a
  call void @__print_int(i32 %0)</code></pre>
<p>representing the successive assignments of variable <code>a</code>. Do not worry with the useless initial assignment; once we will go through the LLVM optimizer, the useless assignment to <code>1</code> will be removed from the final code automatically and look like:</p>
<pre><code>define i32 @main() local_unnamed_addr {
entry:
  tail call void @__print_int(i32 3)
  ret i32 0
}</code></pre>
<p>You can see it by yourself by piping the result of the <code>dtiger</code> compiler through <code>opt -O3 | llvm-dis</code>:</p>
<pre><code>$ src/driver/dtiger -i --dump-ir test.tig | opt -O3 | llvm-dis</code></pre>
<p><em>Note:</em> you might need to add <code>/usr/lib/llvm-3.9/bin</code> to your <code>PATH</code> variable in order to find the <code>opt</code> and <code>llvm-dis</code> tools.</p>
<h2 id="tests-and-branches">Tests and branches</h2>
<p>Translating a <code>IfThenElse</code> AST node into IR is simple but requires several steps. In Tiger, a <code>if … then … else …</code> expression might return a value, as in</p>
<pre><code>let var a := if 2 &gt; 3 then 10 else 20 in … end</code></pre>
<p>So the various steps needed to translate such a node are:</p>
<ul>
<li>Allocate stack space (in the entry block) to represent the result (let’s call it <code>%result</code>).</li>
<li>Build three new basic blocks: the <code>if_then</code> block to represent the <code>then</code> alternative, the <code>if_else</code> block to represent the <code>else</code> alternative, and the <code>if_end</code> block as the join point where the execution will resume after the <code>if … then … else …</code>.</li>
<li>Evaluate the test condition and either branch to the <code>if_then</code> block or to the <code>if_else</code> block depending on the test evaluation (not 0 / 0). Do not forget that the conditional branch needs a <code>i1</code> (boolean) as a parameter, not a <code>i32</code>. You might want to look for the <code>Builder.CreateICmpNE()</code> helper function to compare your value to the constant 0.</li>
<li>In the <code>if_then</code> block, evaluate the body, assign its value to the <code>%result</code> variable, and branch to the <code>if_end</code> block.</li>
<li>Do the same thing for the <code>if_else</code> branch.</li>
<li>Set the current insertion point to be the <code>if_end</code> block so that the code generation continues from there.</li>
<li>Load and return the result stored in <code>%result</code>.</li>
</ul>
<p>There is one pitfall however: if the <code>if …</code> expression is of type <code>void</code>, then the <code>%result</code> variable must not be written to or read from (and <code>nullptr</code> must be returned by <code>visit</code>).</p>
<ol start="5" class="example" type="1">
<li>Implement the visitor for <code>IfThenElse</code> AST nodes.</li>
</ol>
<p>Do not forget to test your implementation using tests with and without <code>else</code>, and tests returning either a value or nothing.</p>
<h2 id="loops">Loops</h2>
<ol start="6" class="example" type="1">
<li><p>Implement the visitor for <code>WhileLoop</code> without taking care of Tiger <code>break</code> statements at this time.</p></li>
<li><p>Implement the visitor for <code>Break</code>. You need to use modify the <code>WhileLoop</code> and <code>ForLoop</code> visitors in order to associate the loop AST nodes with their exit blocks using the <code>loop_exit_bbs</code> map.</p></li>
</ol>
</body>
</html>
